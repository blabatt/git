\section{Advanced \textbackslash \hspace{1mm} Miscellaneous}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{git submodule}
\# Add a submodule to your project:\\
\code{git submodule add <url>} \# add submodule \\
\# Getting a project with submodules:\\
\code{git clone --recurse-submodule <url>} \# init all\\
\# ... or, if you forget to --recurse-submodule, \\
\# you can initialize each SM manually:\\
\code{git submodule init} \# initialize single SM \\
\code{git submodule update} \# fetch \& checkout \\
\# where \say{update} is the usual wrapper:\\
\code{cd <SM>; git fetch; git merge} \# $\equiv$ update \\
\code{git diff --submodule} \# show SM $\Delta$s \\
\# Pull (or push) a repo with $\Delta$ed submodules:\\
\code{git pull --recurse-submodules} \# or use update \\
\# Merge or rebase (--rebase) local \& remote $\Delta$s:\\
\code{git submodule update --remote --merge}\\
\# Do same $\Delta$s across all SMs:\\
\code{git submodule foreach \textquotesingle <cmd>\textquotesingle} \# cmd is bash\\
Handy configurations:
%\begin{multicols}{2}
{\scriptsize
\begin{itemize}
\item diff.submodule
\item submodule.<SM>.branch
\item status.submodulesummary
\item submodule.recurse***
\item push.recurseSubmodules
\end{itemize}}
%\end{multicols}
\\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{git rerere}
Automatically resolve conflicts similar to ones you've fixed in previous merges. Rerere essentially caches pre- and post-merge diffs. \\
\code{git config --global rerere.enabled true}\\
\code{git rerere} \# direct invocation \\





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Porcelain}
{\scriptsize
\begin{tabular}{r l}
archive & create tarball, etc of .git filesystem\\
bundle & package \& share w/o network \\
fsck & \\
gc & manually invoke git garb. collector\\
replace & $\Delta$ hashes for similar commits \\
\end{tabular}}
\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Plumbing}
\say{Object} $\in$ \{blob (file), tree, commit, tag\}\\
\say{Reference} $\in$ \{head (branch), tag, remote\} \\
{\scriptsize
\begin{tabular}{r l}
cat-file & inspect git object (try: -p -t)\\
commit-tree & requires 1 tree (content) \& n objects \\
filter-branch & $\Delta$ all history!!\\
hash-object & create [\& write] objects into git db\\
ls-files & \\
ls-remote & \\
ls-tree & \\
read-tree & load tree into index \\
rev-list & \\
rev-parse & \\
show-branch & \\
show-graph & \\
symbolic-ref & set HEAD \\
update-index & $\Delta$ \& add to index from file or gitdb\\
update-ref & set branch, HEAD, tag pointers\\
verify-pack & show how git packs $\Delta$s into \say{packfiles}\\
write-tree & create tree from index \\
\end{tabular}} \\

\subsection*{Refspec}
Syntax is: [+]<src>:<dest>  Often, can use <refspec> instead of a <ref> like a branch, tag, etc.\\
\ \\















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection*{git filter-branch}
%\code{git filter-branch '<bash\_code>'} \# $\Delta$ all history!!\\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection*{git rev-list}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection*{git archive}
%\code{git archive master | gzip > `git describe`.tar.gz}\\


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection*{git hash-object}
%Used for importing non-commits into git db:\\
%\code{gpg --export | git hash-object --stdin} \# PGP key\\